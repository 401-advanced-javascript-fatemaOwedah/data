  
'use strict';

const Graph = require('../challenges/getEdge/get-edge');

describe('Graph Class',()=>{
  it('Node can be successfully added to the graph',()=>{
    const graph = new Graph.Graph();
    const one = new Graph.Vertices('1');
    const two = new Graph.Vertices('2');
    const three = new Graph.Vertices('3');
    const four = new Graph.Vertices('4');
    const five = new Graph.Vertices('5');
    graph.addNode(one);
    expect(graph.adjancyList.has(one)).toBeTruthy();
    graph.addNode(two);
    expect(graph.adjancyList.has(two)).toBeTruthy();
    graph.addNode(three);
    expect(graph.adjancyList.has(three)).toBeTruthy();
    graph.addNode(four);
    expect(graph.adjancyList.has(four)).toBeTruthy();
    graph.addNode(five);
    expect(graph.adjancyList.has(five)).toBeTruthy();
  });
  it('An edge can be successfully added to the graph',()=>{
    const graph = new Graph.Graph();
    const one = new Graph.Vertices('1');
    const two = new Graph.Vertices('2');
    const three = new Graph.Vertices('3');
    const four = new Graph.Vertices('4');
    const five = new Graph.Vertices('5');
    const six = new Graph.Vertices('6');
    graph.addNode(one);
    graph.addNode(two);
    graph.addNode(three);
    graph.addNode(four);
    graph.addNode(five);
    graph.addEdge(one,two);
    expect(graph.adjancyList.get(one)).toEqual([{vertice:two,weight:0}]);
    graph.addEdge(one,four);
    expect(graph.adjancyList.get(one)).toEqual([{vertice:two,weight:0},{vertice:four,weight:0}]);
    graph.addEdge(two,four);
    expect(graph.adjancyList.get(two)).toEqual([{vertice:four,weight:0}]);
    graph.addEdge(three,two);
    expect(graph.adjancyList.get(three)).toEqual([{vertice:two,weight:0}]);
    graph.addEdge(five,three);
    expect(graph.adjancyList.get(five)).toEqual([{vertice:three,weight:0}]);
    graph.addEdge(five,four);
    expect(graph.adjancyList.get(five)).toEqual([{vertice:three,weight:0},{vertice:four,weight:0}]);
    expect(graph.addEdge(six,four)).toEqual('no Vertices');
  });
  it('A collection of all nodes can be properly retrieved from the graph',()=>{
    const graph = new Graph.Graph();
    const one = new Graph.Vertices('1');
    const two = new Graph.Vertices('2');
    const three = new Graph.Vertices('3');
    const four = new Graph.Vertices('4');
    const five = new Graph.Vertices('5');
    graph.addNode(one);
    graph.addNode(two);
    graph.addNode(three);
    graph.addNode(four);
    graph.addNode(five);
    graph.addEdge(one,two);
    graph.addEdge(one,four);
    graph.addEdge(two,four);
    graph.addEdge(three,two);
    graph.addEdge(five,three);
    graph.addEdge(five,four);
    let result = [
      [ one, [{vertice:two,weight:0},{vertice:four,weight:0}] ],
      [two , [{vertice:four,weight:0}]],
      [ three, [{vertice:two,weight:0}]],
      [four , [] ],
      [five , [{vertice:three,weight:0},{vertice:four,weight:0}]],
    ];
    expect(graph.getNodes()).toEqual(result);
  });
  it('All appropriate neighbors can be retrieved from the graph',()=>{
    const graph = new Graph.Graph();
    const one = new Graph.Vertices('1');
    const two = new Graph.Vertices('2');
    const three = new Graph.Vertices('3');
    const four = new Graph.Vertices('4');
    graph.addNode(one);
    graph.addNode(two);
    graph.addNode(four);
    graph.addEdge(one,two);
    graph.addEdge(one,four);
    expect(graph.getNeighbors(one)).toEqual([{vertice:two,weight:0},{vertice:four,weight:0}]);
    expect(graph.getNeighbors(three)).toEqual('not found');
  });
  it('Neighbors are returned with the weight between nodes included',()=>{
    const graph = new Graph.Graph();
    const one = new Graph.Vertices('1');
    const two = new Graph.Vertices('2');
    const three = new Graph.Vertices('3');
    const four = new Graph.Vertices('4');
    graph.addNode(one);
    graph.addNode(two);
    graph.addNode(four);
    graph.addEdge(one,two);
    graph.addEdge(one,four);
    expect(graph.getNeighbors(one)).toEqual([{vertice:two,weight:0},{vertice:four,weight:0}]);
    expect(graph.getNeighbors(three)).toEqual('not found');
  });
  it('The proper size is returned, representing the number of nodes in the graph',()=>{
    const graph = new Graph.Graph();
    const one = new Graph.Vertices('1');
    const two = new Graph.Vertices('2');
    const four = new Graph.Vertices('3');
    graph.addNode(one);
    graph.addNode(two);
    graph.addNode(four);
    graph.addEdge(one,two);
    graph.addEdge(one,four);
    expect(graph.size()).toEqual(3);
  });
  it('All appropriate neighbors can be retrieved from the graph',()=>{
    const graph = new Graph.Graph();
    const one = new Graph.Vertices('1');
    const two = new Graph.Vertices('2');
    const three = new Graph.Vertices('3');
    const four = new Graph.Vertices('4');
    graph.addNode(one);
    graph.addNode(two);
    graph.addNode(four);
    graph.addEdge(one,two);
    graph.addEdge(one,four);
    expect(graph.getNeighbors(one)).toEqual([{vertice:two,weight:0},{vertice:four,weight:0}]);
    expect(graph.getNeighbors(three)).toEqual('not found');
  });
  
});
describe('Graph Class',()=>{
  it('if start from end node',()=>{
    const bfs = new Graph.Graph();
    const one = new Graph.Vertices('A');
    const two = new Graph.Vertices('B');
    const three = new Graph.Vertices('C');
    const four = new Graph.Vertices('D');
    const five = new Graph.Vertices('E');
    bfs.addNode(one);
    bfs.addNode(two);
    bfs.addNode(three);
    bfs.addNode(four);
    bfs.addNode(five);
    bfs.addEdge(one,two);
    bfs.addEdge(one,four);
    bfs.addEdge(two,four);
    bfs.addEdge(three,two);
    bfs.addEdge(five,three);
    bfs.addEdge(five,four);
    let result = ['E', 'C', 'D', 'B'];
    expect(bfs.bfs(five)).toEqual(result);
  });
  it('if start from start node',()=>{
    const bfs = new Graph.Graph();
    const one = new Graph.Vertices('A');
    const two = new Graph.Vertices('B');
    const three = new Graph.Vertices('C');
    const four = new Graph.Vertices('D');
    const five = new Graph.Vertices('E');
    bfs.addNode(one);
    bfs.addNode(two);
    bfs.addNode(three);
    bfs.addNode(four);
    bfs.addNode(five);
    bfs.addEdge(one,two);
    bfs.addEdge(one,four);
    bfs.addEdge(two,four);
    bfs.addEdge(three,two);
    bfs.addEdge(five,three);
    bfs.addEdge(five,four);
    let result = ['A', 'B', 'D'];
    expect(bfs.bfs(one)).toEqual(result);
  });
  it('if start from middle node',()=>{
    const bfs = new Graph.Graph();
    const one = new Graph.Vertices('A');
    const two = new Graph.Vertices('B');
    const three = new Graph.Vertices('C');
    const four = new Graph.Vertices('D');
    const five = new Graph.Vertices('E');
    bfs.addNode(one);
    bfs.addNode(two);
    bfs.addNode(three);
    bfs.addNode(four);
    bfs.addNode(five);
    bfs.addEdge(one,two);
    bfs.addEdge(one,four);
    bfs.addEdge(two,four);
    bfs.addEdge(three,two);
    bfs.addEdge(five,three);
    bfs.addEdge(five,four);
    let result = ['C', 'B', 'D'];
    expect(bfs.bfs(three)).toEqual(result);
  });
});

describe('Graph Class',()=>{
  it('1===>check price(edge) of journey',()=>{
    const graph = new Graph.Graph();
    const one = 'Pandora';
    const two =  'Arendelle';
    const three = 'Monstropolis';
    const four =  'Metrovilla';
    const five =  'Naboo';
    graph.addNode(one);
    graph.addNode(two);
    graph.addNode(three);
    graph.addNode(four);
    graph.addNode(five);
    graph.addEdge(one,two,150);
    graph.addEdge(one,four,82);
    graph.addEdge(two,four,99);
    graph.addEdge(three,two,42);
    graph.addEdge(five,three,73);
    graph.addEdge(five,four,27);
    expect(graph.getEdge(['Pandora','Arendelle'])).toEqual('True, $150');
  });
  it('2===>check price(edge) of journey',()=>{
    const graph = new Graph.Graph();
    const one = 'Pandora';
    const two =  'Arendelle';
    const three = 'Monstropolis';
    const four =  'Metrovilla';
    const five =  'Naboo';
    graph.addNode(one);
    graph.addNode(two);
    graph.addNode(three);
    graph.addNode(four);
    graph.addNode(five);
    graph.addEdge(one,two,150);
    graph.addEdge(one,four,82);
    graph.addEdge(two,four,99);
    graph.addEdge(three,two,42);
    graph.addEdge(five,three,73);
    graph.addEdge(five,four,27);
    expect(graph.getEdge(['Pandora','Metrovilla'])).toEqual('True, $82');
  });
  it('3===>check price(edge) of journey',()=>{
    const graph = new Graph.Graph();
    const one = 'Pandora';
    const two =  'Arendelle';
    const three = 'Monstropolis';
    const four =  'Metrovilla';
    const five =  'Naboo';
    graph.addNode(one);
    graph.addNode(two);
    graph.addNode(three);
    graph.addNode(four);
    graph.addNode(five);
    graph.addEdge(one,two,150);
    graph.addEdge(one,four,82);
    graph.addEdge(two,four,99);
    graph.addEdge(three,two,42);
    graph.addEdge(five,three,73);
    graph.addEdge(five,four,27);
    expect(graph.getEdge(['Arendelle','Metrovilla'])).toEqual('True, $99');
  });
  it('4===>check price(edge) of journey',()=>{
    const graph = new Graph.Graph();
    const one = 'Pandora';
    const two =  'Arendelle';
    const three = 'Monstropolis';
    const four =  'Metrovilla';
    const five =  'Naboo';
    graph.addNode(one);
    graph.addNode(two);
    graph.addNode(three);
    graph.addNode(four);
    graph.addNode(five);
    graph.addEdge(one,two,150);
    graph.addEdge(one,four,82);
    graph.addEdge(two,four,99);
    graph.addEdge(three,two,42);
    graph.addEdge(five,three,73);
    graph.addEdge(five,four,27);
    expect(graph.getEdge(['Monstropolis','Arendelle'])).toEqual('True, $42');
  });
  it('5===>check price(edge) of journey',()=>{
    const graph = new Graph.Graph();
    const one = 'Pandora';
    const two =  'Arendelle';
    const three = 'Monstropolis';
    const four =  'Metrovilla';
    const five =  'Naboo';
    graph.addNode(one);
    graph.addNode(two);
    graph.addNode(three);
    graph.addNode(four);
    graph.addNode(five);
    graph.addEdge(one,two,150);
    graph.addEdge(one,four,82);
    graph.addEdge(two,four,99);
    graph.addEdge(three,two,42);
    graph.addEdge(five,three,73);
    graph.addEdge(five,four,27);
    expect(graph.getEdge(['Naboo','Monstropolis'])).toEqual('True, $73');
  });
  it('6===>check price(edge) of journey',()=>{
    const graph = new Graph.Graph();
    const one = 'Pandora';
    const two =  'Arendelle';
    const three = 'Monstropolis';
    const four =  'Metrovilla';
    const five =  'Naboo';
    graph.addNode(one);
    graph.addNode(two);
    graph.addNode(three);
    graph.addNode(four);
    graph.addNode(five);
    graph.addEdge(one,two,150);
    graph.addEdge(one,four,82);
    graph.addEdge(two,four,99);
    graph.addEdge(three,two,42);
    graph.addEdge(five,three,73);
    graph.addEdge(five,four,27);
    expect(graph.getEdge(['Naboo','Metrovilla'])).toEqual('True, $27');
  });
  it('7===>check price(edge) of journey',()=>{
    const graph = new Graph.Graph();
    const one = 'Pandora';
    const two =  'Arendelle';
    const three = 'Monstropolis';
    const four =  'Metrovilla';
    const five =  'Naboo';
    graph.addNode(one);
    graph.addNode(two);
    graph.addNode(three);
    graph.addNode(four);
    graph.addNode(five);
    graph.addEdge(one,two,150);
    graph.addEdge(one,four,82);
    graph.addEdge(two,four,99);
    graph.addEdge(three,two,42);
    graph.addEdge(five,three,73);
    graph.addEdge(five,four,27);
    expect(graph.getEdge(['Pandora','Monstropolis'])).toEqual('False, $0');
  });
  it('8===>check price(edge) of journey',()=>{
    const graph = new Graph.Graph();
    const one = 'Pandora';
    const two =  'Arendelle';
    const three = 'Monstropolis';
    const four =  'Metrovilla';
    const five =  'Naboo';
    graph.addNode(one);
    graph.addNode(two);
    graph.addNode(three);
    graph.addNode(four);
    graph.addNode(five);
    graph.addEdge(one,two,150);
    graph.addEdge(one,four,82);
    graph.addEdge(two,four,99);
    graph.addEdge(three,two,42);
    graph.addEdge(five,three,73);
    graph.addEdge(five,four,27);
    expect(graph.getEdge(['Pandora','Naboo'])).toEqual('False, $0');
  });
});